blueprint:
  name: Intelligent Living Room - mmWave + Lux-Aware v1.7
  description: >
    Professional-grade lighting automation combining mmWave presence detection,
    lux-aware hysteresis anti-flicker logic, staged turn-off sequences, dynamic
    brightness adjustment, sun-aware circadian rhythm, and Philips Hue scene cycling.


    This is v1.7 - CRITICAL FIX: Fixed continuous monitoring loop not running after
    lux_dropped trigger. Also fixed loop variables (loop_override_active, loop_scene_is_active,
    time_override) returning strings instead of booleans. Merged Branch 2C into Branch 3
    so lux_dropped trigger includes continuous circadian updates. NOW WORKING: Circadian
    colors and brightness update every 60 seconds! v1.6 added lux_dropped, v1.5 fixed booleans.


    KEY FEATURES:


    - ANTI-FLICKER HYSTERESIS: Dual-threshold system with separate ON/OFF lux levels
      prevents light flicker. Turn OFF at 150 lux, turn ON at 80 lux. 50 lux dead band
      provides reliable protection against flickering from clouds and natural light changes.


    - MMWAVE PRESENCE: Single sensor design (Aqara FP2, EP1, or similar). Approach
      detection support for instant activation. No complex zone mapping required.


    - DYNAMIC BRIGHTNESS: Brightness scales inversely with ambient lux. Darker rooms
      get brighter lights (≤50 lux = 100%), brighter rooms get dimmer lights (150 lux = 40%).


    - CIRCADIAN RHYTHM: Sun-aware color temperature with 1800K baseline warmth. Uses
      sun elevation for authentic natural lighting. Philips Hue native color_temp/mireds mode.


    - STAGED TURN-OFF: Gradual dimming sequence before lights turn off. Day mode (15/20/25 min):
      Stage 1 @ 15 min (40% + 1800K), Stage 2 @ 20 min (20% + 1800K), Stage 3 @ 25 min (OFF).
      Night mode (5/10/15 min): Faster response after 10pm for bedtime routines.


    - MANUAL OVERRIDE: Button/switch/input_boolean support. Toggle behavior to keep
      lights on regardless of lux. Override disables lux-based turn-off while active.


    - SCENE CYCLING: NEW! Cycle through up to 3 Philips Hue scenes with a single button.
      Press once for Movie Mode, again for Reading Mode, again for Party Mode, again to
      return to normal automation. Scenes override lux-based control and circadian lighting.




    PERFECT FOR: Living rooms, family rooms, media rooms with large windows prone to
    light flicker, spaces requiring gradual turn-off behavior, users who want manual control.


    COMPATIBILITY: Philips Hue, IKEA Tradfri, any tunable white lights. Aqara FP2/EP1,
    any mmWave or PIR presence sensors.

  domain: automation
  source_url: https://github.com/martinlevie/HomeAssistant-Repo/blueprints/intelligent_living_room_mmwave_lux_aware.yaml

  input:
    # ============================================================================
    # SECTION 1: LIGHTS AND TARGET ENTITIES
    # ============================================================================
    target_lights:
      name: Target Lights
      description: >
        Select the lights to control. Must support color temperature (tunable white).
        Works with Philips Hue, IKEA Tradfri, and most smart bulbs with color_temp support.
      selector:
        target:
          entity:
            - domain: light

    # ============================================================================
    # SECTION 2: PRESENCE SENSORS (MMWAVE / PIR)
    # ============================================================================
    presence_sensor:
      name: Primary Presence Sensor
      description: >
        Main presence sensor for the room (Aqara FP2, mmWave, PIR, etc.). Treats entire
        room as one zone - simple and reliable. When presence detected, lights turn on
        (unless lux is too high). When presence clears, staged turn-off begins.
      selector:
        entity:
          filter:
            - domain: binary_sensor

    approach_sensor:
      name: Approach Detection Sensor (Optional)
      description: >
        Optional approach detection sensor (FP2 approach events configured in Aqara app,
        or similar). When triggered, lights turn on immediately even if lux is high -
        perfect for entering bright rooms. Leave empty to disable approach detection.
      default: {}
      selector:
        entity:
          filter:
            - domain: binary_sensor

    # ============================================================================
    # SECTION 3: LUX SENSOR AND ANTI-FLICKER THRESHOLDS
    # ============================================================================
    lux_sensor:
      name: Lux/Illuminance Sensor
      description: >
        Ambient light sensor for lux-aware control. Can be FP2's built-in lux sensor
        or any separate illuminance sensor. Critical for anti-flicker hysteresis system.
        Place sensor where it measures room's natural light (near window but not direct sun).
      selector:
        entity:
          filter:
            - domain: sensor
              device_class: illuminance

    lux_turn_on_threshold:
      name: Lux Turn-ON Threshold
      description: >
        Lights can turn ON when lux drops BELOW this value (if presence detected).
        Default: 80 lux. This is the LOWER threshold of the hysteresis band. Lower values
        = lights only activate in darker conditions.
      default: 80
      selector:
        number:
          min: 20
          max: 200
          step: 5
          unit_of_measurement: lux
          mode: slider

    lux_turn_off_threshold:
      name: Lux Turn-OFF Threshold
      description: >
        Lights will turn OFF when lux rises ABOVE this value. Default: 150 lux.
        This is the UPPER threshold of the hysteresis band. Must be higher than turn-ON
        threshold to create hysteresis gap (prevents flickering). Higher values = lights
        stay on even when fairly bright.
      default: 150
      selector:
        number:
          min: 50
          max: 500
          step: 10
          unit_of_measurement: lux
          mode: slider

    # ============================================================================
    # SECTION 4: MANUAL OVERRIDE SYSTEM
    # ============================================================================
    override_enabled:
      name: Enable Manual Override System
      description: >
        Enable manual override (movie mode, party mode, etc.) to keep lights on regardless
        of lux level. User can activate via button press, switch toggle, or input_boolean.
        Toggle behavior: press once = ON, press again = OFF.
      default: true
      selector:
        boolean:

    override_trigger:
      name: Override Trigger Entity (Optional)
      description: >
        Entity to trigger manual override toggle. Can be:
        - Physical button (Aqara wireless button, Hue dimmer switch)
        - Physical switch entity
        - Virtual input_boolean helper
        - Any binary sensor
        Leave empty if override system is disabled. Each activation flips override state.
      default: {}
      selector:
        entity:

    # ============================================================================
    # SECTION 4B: SCENE CYCLING OVERRIDE SYSTEM (NEW v1.1)
    # ============================================================================
    scene_cycling_enabled:
      name: Enable Scene Cycling System
      description: >
        Enable advanced scene cycling with a single button. Press once for Scene 1,
        again for Scene 2, again for Scene 3, again to return to normal automation.
        Perfect for Movie Mode, Reading Mode, Party Mode presets. Requires input_number
        helper for state tracking (create via Settings > Helpers).
      default: false
      selector:
        boolean:

    scene_state_tracker:
      name: Scene State Tracker Helper (Required for Scene Cycling)
      description: >
        input_number helper to track which scene is active (0=Off, 1=Scene1, 2=Scene2, 3=Scene3).
        CREATE THIS FIRST: Settings > Devices & Services > Helpers > Create Helper > Number.
        Set Min=0, Max=3, Step=1. See setup guide for detailed instructions.
      default: {}
      selector:
        entity:
          filter:
            - domain: input_number

    scene_cycle_button:
      name: Scene Cycle Button (Required for Scene Cycling)
      description: >
        Button or entity to cycle through scene overrides. Each press advances to next scene.
        Can be physical button (Hue dimmer, Aqara button) or virtual input_button/input_boolean.
        Supports button, event, switch, input_boolean, input_button domains.
      default: {}
      selector:
        entity:
          filter:
            - domain: [button, event, switch, input_boolean, input_button]

    # --- Scene 1 Configuration ---
    override_scene_1_enabled:
      name: Enable Scene 1
      description: >
        Enable first scene in cycle (e.g., Movie Mode). If disabled, button press will skip
        to next enabled scene. Disable all scenes to effectively disable scene cycling.
      default: true
      selector:
        boolean:

    override_scene_1:
      name: Scene 1 Entity (e.g., Movie Mode)
      description: >
        Philips Hue scene or Home Assistant scene to activate for Scene 1. Scene must be
        created first (via Philips Hue app or HA Scenes). Leave empty if Scene 1 disabled.
      default: {}
      selector:
        entity:
          filter:
            - domain: scene

    override_scene_1_name:
      name: Scene 1 Name
      description: >
        Display name for Scene 1 (for logging/debugging). Examples: "Movie Mode", "Cozy Evening",
        "TV Time". Does not affect scene activation - only for human reference.
      default: "Movie Mode"
      selector:
        text:

    # --- Scene 2 Configuration ---
    override_scene_2_enabled:
      name: Enable Scene 2
      description: >
        Enable second scene in cycle (e.g., Reading Mode). If disabled, button press will skip
        to next enabled scene.
      default: true
      selector:
        boolean:

    override_scene_2:
      name: Scene 2 Entity (e.g., Reading Mode)
      description: >
        Philips Hue scene or Home Assistant scene to activate for Scene 2. Scene must be
        created first (via Philips Hue app or HA Scenes). Leave empty if Scene 2 disabled.
      default: {}
      selector:
        entity:
          filter:
            - domain: scene

    override_scene_2_name:
      name: Scene 2 Name
      description: >
        Display name for Scene 2 (for logging/debugging). Examples: "Reading Mode", "Bright Focus",
        "Work Mode". Does not affect scene activation - only for human reference.
      default: "Reading Mode"
      selector:
        text:

    # --- Scene 3 Configuration ---
    override_scene_3_enabled:
      name: Enable Scene 3
      description: >
        Enable third scene in cycle (e.g., Party Mode). If disabled, button press will skip
        to next enabled scene or cycle back to Off.
      default: true
      selector:
        boolean:

    override_scene_3:
      name: Scene 3 Entity (e.g., Party Mode)
      description: >
        Philips Hue scene or Home Assistant scene to activate for Scene 3. Scene must be
        created first (via Philips Hue app or HA Scenes). Leave empty if Scene 3 disabled.
      default: {}
      selector:
        entity:
          filter:
            - domain: scene

    override_scene_3_name:
      name: Scene 3 Name
      description: >
        Display name for Scene 3 (for logging/debugging). Examples: "Party Mode", "Colorful",
        "Energetic". Does not affect scene activation - only for human reference.
      default: "Party Mode"
      selector:
        text:

    # --- Scene Behavior Configuration ---
    scene_bypass_presence_timeout:
      name: Scene Bypass Presence Timeout
      description: >
        When scene is active, should it bypass the presence timeout (staged turn-off)?
        ENABLED: Scene stays on indefinitely until manually cycled off (ignores presence).
        DISABLED: Scene respects staged turn-off timing (30/40/45 min when presence clears).
        Recommended: DISABLED for safety, ENABLED for movie nights.
      default: false
      selector:
        boolean:

    # ============================================================================
    # SECTION 5: DYNAMIC BRIGHTNESS SETTINGS
    # ============================================================================
    dynamic_brightness_enabled:
      name: Enable Dynamic Brightness
      description: >
        Automatically adjust brightness based on natural light levels. Brightness scales
        inversely with lux (brighter outside = dimmer lights, darker outside = brighter lights).
        Works seamlessly with circadian color temperature. Recommended: ENABLED.
      default: true
      selector:
        boolean:

    # Dynamic brightness curve configuration
    brightness_50_lux:
      name: Brightness at ≤50 Lux
      description: >
        Brightness level when very dark (≤50 lux). Default: 100% (full brightness in darkness).
      default: 100
      selector:
        number:
          min: 40
          max: 100
          step: 5
          unit_of_measurement: "%"
          mode: slider

    brightness_75_lux:
      name: Brightness at 75 Lux
      description: >
        Brightness level at 75 lux. Default: 85% (slightly dimmed as natural light increases).
      default: 85
      selector:
        number:
          min: 30
          max: 100
          step: 5
          unit_of_measurement: "%"
          mode: slider

    brightness_100_lux:
      name: Brightness at 100 Lux
      description: >
        Brightness level at 100 lux (mid-range). Default: 70%.
      default: 70
      selector:
        number:
          min: 20
          max: 100
          step: 5
          unit_of_measurement: "%"
          mode: slider

    brightness_125_lux:
      name: Brightness at 125 Lux
      description: >
        Brightness level at 125 lux. Default: 55%.
      default: 55
      selector:
        number:
          min: 20
          max: 100
          step: 5
          unit_of_measurement: "%"
          mode: slider

    brightness_150_lux:
      name: Brightness at 150 Lux (OFF Threshold)
      description: >
        Brightness level at 150 lux (at OFF threshold). Default: 40%. This is the dimmest
        the lights will go before turning off completely when lux exceeds OFF threshold.
      default: 40
      selector:
        number:
          min: 15
          max: 100
          step: 5
          unit_of_measurement: "%"
          mode: slider

    # ============================================================================
    # SECTION 6: CIRCADIAN RHYTHM (SUN-AWARE)
    # ============================================================================
    circadian_enabled:
      name: Enable Circadian Rhythm
      description: >
        Enable sun-aware circadian color temperature. Uses actual sun elevation angles
        (adapted from proven sun-aware blueprint). Warmest baseline: 1800K. Updates every
        60 seconds with smooth 3-5 second transitions. Recommended: ENABLED.
      default: true
      selector:
        boolean:

    circadian_update_interval:
      name: Circadian Update Frequency
      description: >
        How often to update color temperature based on sun position. Default: 60 seconds
        (responsive without being excessive). Lower = more responsive but more automation triggers.
      default: 60
      selector:
        number:
          min: 30
          max: 300
          step: 30
          unit_of_measurement: seconds
          mode: slider

    circadian_transition_duration:
      name: Circadian Transition Duration
      description: >
        Smoothness of color temperature transitions. Default: 4 seconds (balanced - smooth
        but not sluggish). Increase for gentler changes, decrease for snappier response.
      default: 4
      selector:
        number:
          min: 1
          max: 10
          step: 1
          unit_of_measurement: seconds
          mode: slider

    # ============================================================================
    # SECTION 7: STAGED TURN-OFF (PROGRESSIVE WARNINGS)
    # ============================================================================
    staged_turnoff_enabled:
      name: Enable Staged Turn-Off
      description: >
        Enable progressive warnings before complete shut-off. Prevents jarring sudden darkness.
        Three stages: 30 min (dim + warm), 40 min (dimmer), 45 min (off). User-configurable
        timing and brightness. Recommended: ENABLED.
      default: true
      selector:
        boolean:

    stage_1_delay:
      name: Stage 1 Delay (First Warning)
      description: >
        Time of no presence before first warning (dim + warm color). Default: 15 minutes.
        Lights dim to Stage 1 brightness and shift to 1800K warm warning color.
      default: 900
      selector:
        number:
          min: 300
          max: 3600
          step: 300
          unit_of_measurement: seconds
          mode: slider

    stage_1_brightness:
      name: Stage 1 Brightness
      description: >
        Brightness level for first warning stage. Default: 40%. Noticeable dim but still
        functional if you return to room.
      default: 40
      selector:
        number:
          min: 10
          max: 80
          step: 5
          unit_of_measurement: "%"
          mode: slider

    stage_2_delay:
      name: Stage 2 Delay (Second Warning)
      description: >
        Time of no presence before second warning (dimmer). Default: 20 minutes. Lights
        dim further to Stage 2 brightness, still at 1800K warm.
      default: 1200
      selector:
        number:
          min: 600
          max: 4200
          step: 300
          unit_of_measurement: seconds
          mode: slider

    stage_2_brightness:
      name: Stage 2 Brightness
      description: >
        Brightness level for second warning stage. Default: 20%. Very dim - strong warning
        that lights will turn off soon.
      default: 20
      selector:
        number:
          min: 5
          max: 50
          step: 5
          unit_of_measurement: "%"
          mode: slider

    stage_3_delay:
      name: Stage 3 Delay (Complete Turn-Off)
      description: >
        Time of no presence before complete turn-off. Default: 25 minutes (1500 seconds).
        Lights turn off completely with 3-second fade.
      default: 1500
      selector:
        number:
          min: 900
          max: 5400
          step: 300
          unit_of_measurement: seconds
          mode: slider

    # ============================================================================
    # SECTION 8: NIGHT MODE (FAST SHUTDOWN AFTER HOURS)
    # ============================================================================
    night_mode_enabled:
      name: Enable Night Mode Fast Shutdown
      description: >
        Enable faster staged turn-off after a specified time (e.g., 10pm bedtime).
        When enabled, uses shorter delays for quicker response to no presence during
        late evening hours. Perfect for bedtime routines when you want lights to turn
        off faster. Recommended: ENABLED.
      default: true
      selector:
        boolean:

    night_mode_start_time:
      name: Night Mode Start Time
      description: >
        Time when night mode fast shutdown begins (24-hour format). Default: 22:00 (10pm).
        After this time, staged turn-off uses night mode delays instead of normal delays.
      default: "22:00:00"
      selector:
        time:

    night_mode_end_time:
      name: Night Mode End Time
      description: >
        Time when night mode ends (24-hour format). Default: 06:00 (6am). Between
        end time and start time, normal staged turn-off delays are used.
      default: "06:00:00"
      selector:
        time:

    night_stage_1_delay:
      name: Night Mode Stage 1 Delay
      description: >
        Stage 1 delay during night mode (first warning). Default: 5 minutes (300 seconds).
        Much faster than normal mode for quicker response at bedtime.
      default: 300
      selector:
        number:
          min: 60
          max: 1800
          step: 60
          unit_of_measurement: seconds
          mode: slider

    night_stage_2_delay:
      name: Night Mode Stage 2 Delay
      description: >
        Stage 2 delay during night mode (second warning). Default: 10 minutes (600 seconds).
      default: 600
      selector:
        number:
          min: 120
          max: 2400
          step: 60
          unit_of_measurement: seconds
          mode: slider

    night_stage_3_delay:
      name: Night Mode Stage 3 Delay
      description: >
        Stage 3 delay during night mode (complete turn-off). Default: 15 minutes (900 seconds).
        Lights turn off completely after this duration with no presence.
      default: 900
      selector:
        number:
          min: 180
          max: 3000
          step: 60
          unit_of_measurement: seconds
          mode: slider

# Automation mode: restart ensures clean state management
# If presence detected during any stage, automation restarts from beginning
mode: restart
max_exceeded: silent

variables:
  # === CORE ENTITY REFERENCES ===
  lux_sensor_entity: !input lux_sensor
  presence_sensor_entity: !input presence_sensor
  approach_sensor_entity: !input approach_sensor
  override_trigger_entity: !input override_trigger

  # === SCENE CYCLING SYSTEM REFERENCES ===
  scene_cycling_system_enabled: !input scene_cycling_enabled
  scene_tracker_entity: !input scene_state_tracker
  scene_button_entity: !input scene_cycle_button

  # Scene 1 configuration
  scene_1_enabled: !input override_scene_1_enabled
  scene_1_entity: !input override_scene_1
  scene_1_name: !input override_scene_1_name

  # Scene 2 configuration
  scene_2_enabled: !input override_scene_2_enabled
  scene_2_entity: !input override_scene_2
  scene_2_name: !input override_scene_2_name

  # Scene 3 configuration
  scene_3_enabled: !input override_scene_3_enabled
  scene_3_entity: !input override_scene_3
  scene_3_name: !input override_scene_3_name

  # Scene behavior
  scene_bypass_timeout: !input scene_bypass_presence_timeout

  # === LUX THRESHOLDS ===
  lux_on_threshold: !input lux_turn_on_threshold
  lux_off_threshold: !input lux_turn_off_threshold

  # === FEATURE FLAGS ===
  override_system_enabled: !input override_enabled
  dynamic_brightness: !input dynamic_brightness_enabled
  circadian_rhythm: !input circadian_enabled
  staged_turnoff: !input staged_turnoff_enabled

  # === DYNAMIC BRIGHTNESS LEVELS ===
  brightness_at_50_lux: !input brightness_50_lux
  brightness_at_75_lux: !input brightness_75_lux
  brightness_at_100_lux: !input brightness_100_lux
  brightness_at_125_lux: !input brightness_125_lux
  brightness_at_150_lux: !input brightness_150_lux

  # === CIRCADIAN SETTINGS ===
  circadian_update_sec: !input circadian_update_interval
  circadian_transition_sec: !input circadian_transition_duration

  # === STAGED TURN-OFF TIMING ===
  stage_1_delay_sec: !input stage_1_delay
  stage_1_brightness_pct: !input stage_1_brightness
  stage_2_delay_sec: !input stage_2_delay
  stage_2_brightness_pct: !input stage_2_brightness
  stage_3_delay_sec: !input stage_3_delay

  # === NIGHT MODE CONFIGURATION ===
  night_mode_enabled_flag: !input night_mode_enabled
  night_mode_start: !input night_mode_start_time
  night_mode_end: !input night_mode_end_time
  night_stage_1_delay_sec: !input night_stage_1_delay
  night_stage_2_delay_sec: !input night_stage_2_delay
  night_stage_3_delay_sec: !input night_stage_3_delay

  # === NIGHT MODE ACTIVE CHECK ===
  # Check if current time is within night mode window
  is_night_mode_active: >
    {% if night_mode_enabled_flag %}
      {% set current_time = now().strftime('%H:%M:%S') %}
      {% set start = night_mode_start %}
      {% set end = night_mode_end %}
      {% if start < end %}
        {# Normal case: start before midnight, end after midnight (e.g., 22:00 to 06:00 next day) #}
        {{ current_time >= start or current_time < end }}
      {% else %}
        {# Crossing midnight case: start after end (e.g., 22:00 to 06:00) #}
        {{ current_time >= start or current_time < end }}
      {% endif %}
    {% else %}
      false
    {% endif %}

  # === EFFECTIVE STAGED DELAYS (SWITCHES BASED ON NIGHT MODE) ===
  effective_stage_1_delay: >
    {% if is_night_mode_active %}
      {{ night_stage_1_delay_sec }}
    {% else %}
      {{ stage_1_delay_sec }}
    {% endif %}

  effective_stage_2_delay: >
    {% if is_night_mode_active %}
      {{ night_stage_2_delay_sec }}
    {% else %}
      {{ stage_2_delay_sec }}
    {% endif %}

  effective_stage_3_delay: >
    {% if is_night_mode_active %}
      {{ night_stage_3_delay_sec }}
    {% else %}
      {{ stage_3_delay_sec }}
    {% endif %}

  # === CURRENT LUX READING ===
  current_lux: "{{ states(lux_sensor_entity) | float(0) }}"

  # === SUN POSITION DATA ===
  sun_elevation: "{{ state_attr('sun.sun', 'elevation') | float(0) }}"

  # === OVERRIDE SYSTEM STATE ===
  # Check if override is currently active (using input_boolean, binary_sensor, or switch state)
  override_active: >
    {{ override_system_enabled and override_trigger_entity and is_state(override_trigger_entity, 'on') }}

  # === SCENE CYCLING STATE ===
  # Get current scene state from input_number (0=Off, 1=Scene1, 2=Scene2, 3=Scene3)
  current_scene_state: >
    {% if scene_cycling_system_enabled and scene_tracker_entity %}
      {{ states(scene_tracker_entity) | int(0) }}
    {% else %}
      0
    {% endif %}

  # Check if ANY scene is currently active (state > 0)
  scene_is_active: >
    {{ scene_cycling_system_enabled and scene_tracker_entity and (states(scene_tracker_entity) | int(0)) > 0 }}

  # === DYNAMIC BRIGHTNESS CALCULATION ===
  # Brightness scales inversely with lux (brighter outside = dimmer lights)
  calculated_brightness: >
    {% if dynamic_brightness %}
      {% set lux = current_lux | float %}
      {% if lux <= 50 %}
        {{ brightness_at_50_lux }}
      {% elif lux <= 75 %}
        {# Linear interpolation between 50 and 75 lux #}
        {% set range_pct = (lux - 50) / 25 %}
        {{ (brightness_at_50_lux - (brightness_at_50_lux - brightness_at_75_lux) * range_pct) | int }}
      {% elif lux <= 100 %}
        {# Linear interpolation between 75 and 100 lux #}
        {% set range_pct = (lux - 75) / 25 %}
        {{ (brightness_at_75_lux - (brightness_at_75_lux - brightness_at_100_lux) * range_pct) | int }}
      {% elif lux <= 125 %}
        {# Linear interpolation between 100 and 125 lux #}
        {% set range_pct = (lux - 100) / 25 %}
        {{ (brightness_at_100_lux - (brightness_at_100_lux - brightness_at_125_lux) * range_pct) | int }}
      {% elif lux <= 150 %}
        {# Linear interpolation between 125 and 150 lux #}
        {% set range_pct = (lux - 125) / 25 %}
        {{ (brightness_at_125_lux - (brightness_at_125_lux - brightness_at_150_lux) * range_pct) | int }}
      {% else %}
        {# Above 150 lux - use minimum brightness #}
        {{ brightness_at_150_lux }}
      {% endif %}
    {% else %}
      100  {# Default full brightness if dynamic brightness disabled #}
    {% endif %}

  # === CIRCADIAN COLOR TEMPERATURE CALCULATION (SUN-AWARE) ===
  # Adapted from sun-aware blueprint with 1800K warmest baseline
  color_temp_kelvin: >
    {% if circadian_rhythm %}
      {% set elevation = sun_elevation | float %}

      {# Deep night (sun well below horizon) #}
      {% if elevation < -6 %}
        1800

      {# Civil twilight (sun just below horizon) - gentle warm transition #}
      {% elif elevation >= -6 and elevation < 0 %}
        {{ (1800 + (elevation + 6) * 200) | int }}  {# 1800K to 3000K #}

      {# Low sun (sunrise/sunset) - warming up or cooling down #}
      {% elif elevation >= 0 and elevation < 10 %}
        {{ (3000 + (elevation * 50)) | int }}  {# 3000K to 3500K #}

      {# Rising/falling sun - energizing transition #}
      {% elif elevation >= 10 and elevation < 30 %}
        {{ (3500 + (elevation - 10) * 75) | int }}  {# 3500K to 5000K #}

      {# High sun - peak alertness #}
      {% elif elevation >= 30 and elevation < 50 %}
        {{ (5000 + (elevation - 30) * 25) | int }}  {# 5000K to 5500K #}

      {# Very high sun (summer midday) - maximum cool daylight #}
      {% else %}
        5500
      {% endif %}
    {% else %}
      3000  {# Default warm white if circadian disabled #}
    {% endif %}

  # === CONVERT KELVIN TO MIREDS (Philips Hue native format) ===
  # Formula: mireds = 1,000,000 / kelvin
  # Ensures compatibility with color_temp service calls
  color_temp_mireds: "{{ (1000000 / (color_temp_kelvin | int)) | int }}"

  # === STAGED TURN-OFF WARNING COLOR ===
  # Always 1800K warm during staged warnings (converted to mireds)
  warning_color_temp_mireds: "{{ (1000000 / 1800) | int }}"

trigger:
  # === TRIGGER 1: PRIMARY PRESENCE DETECTION ===
  # Main presence sensor triggers automation start
  - platform: state
    entity_id: !input presence_sensor
    to: "on"
    id: presence_detected

  # === TRIGGER 2: APPROACH DETECTION (OPTIONAL) ===
  # Approach sensor triggers immediate activation (bypasses lux check temporarily)
  - platform: state
    entity_id: !input approach_sensor
    to: "on"
    id: approach_detected

  # === TRIGGER 3: MANUAL OVERRIDE TOGGLE ===
  # Override trigger activates/deactivates manual override mode
  - platform: state
    entity_id: !input override_trigger
    id: override_toggled

  # === TRIGGER 3B: SCENE CYCLE BUTTON ===
  # Scene cycling button press - cycles through 3 scenes and back to off
  - platform: state
    entity_id: !input scene_cycle_button
    id: scene_cycle_pressed

  # === TRIGGER 4: CIRCADIAN UPDATE CYCLE ===
  # Periodic update for circadian color temperature (every 60 seconds by default)
  - platform: time_pattern
    minutes: "/1"
    id: circadian_update

  # === TRIGGER 5: LUX EXCEEDED OFF THRESHOLD ===
  # Lux sensor triggers when ambient light exceeds OFF threshold
  # This allows lights to turn off when room becomes bright (e.g., sunrise, curtains opened)
  # Works independently of the 60-second loop check for faster response
  - platform: numeric_state
    entity_id: !input lux_sensor
    above: !input lux_turn_off_threshold
    id: lux_exceeded

  # === TRIGGER 6: LUX DROPPED BELOW ON THRESHOLD ===
  # Lux sensor triggers when ambient light drops below ON threshold
  # This allows lights to turn on when room becomes dark (e.g., sunset, curtains closed)
  # Works independently of the 60-second loop check for faster response
  - platform: numeric_state
    entity_id: !input lux_sensor
    below: !input lux_turn_on_threshold
    id: lux_dropped

action:
  # === ACTION FLOW DECISION TREE ===
  - choose:
      # ======================================================================
      # BRANCH 1: MANUAL OVERRIDE TOGGLE
      # ======================================================================
      - conditions:
          - condition: trigger
            id: override_toggled
        sequence:
          # Override trigger pressed - toggle state is handled by the entity itself
          # (input_boolean, switch, or binary_sensor already changes state)
          # No action needed here - automation will check override_active variable
          # on next presence/approach trigger
          - service: system_log.write
            data:
              message: "Override toggled. New state: {{ override_active }}"
              level: info

      # ======================================================================
      # BRANCH 1B: SCENE CYCLE BUTTON PRESSED (NEW v1.1)
      # ======================================================================
      - conditions:
          - condition: trigger
            id: scene_cycle_pressed
          - condition: template
            value_template: "{{ scene_cycling_system_enabled }}"
          - condition: template
            value_template: "{{ scene_tracker_entity != none and scene_tracker_entity != '' }}"
        sequence:
          # === SCENE CYCLING LOGIC ===
          # Calculate next state based on current state and which scenes are enabled
          # Current state from input_number: 0 (off) | 1 (scene1) | 2 (scene2) | 3 (scene3)
          # Logic: Find next enabled scene, or wrap to 0 if at end

          - variables:
              # Get current state
              current_state: "{{ states(scene_tracker_entity) | int(0) }}"

              # Calculate next state (cycle through enabled scenes only)
              next_state: >
                {% set current = states(scene_tracker_entity) | int(0) %}
                {% if current == 0 %}
                  {# Currently off - find first enabled scene #}
                  {% if scene_1_enabled and scene_1_entity %}
                    1
                  {% elif scene_2_enabled and scene_2_entity %}
                    2
                  {% elif scene_3_enabled and scene_3_entity %}
                    3
                  {% else %}
                    0
                  {% endif %}
                {% elif current == 1 %}
                  {# Currently scene 1 - find next enabled scene #}
                  {% if scene_2_enabled and scene_2_entity %}
                    2
                  {% elif scene_3_enabled and scene_3_entity %}
                    3
                  {% else %}
                    0
                  {% endif %}
                {% elif current == 2 %}
                  {# Currently scene 2 - find next enabled scene #}
                  {% if scene_3_enabled and scene_3_entity %}
                    3
                  {% else %}
                    0
                  {% endif %}
                {% else %}
                  {# Currently scene 3 or invalid state - cycle back to off #}
                  0
                {% endif %}

          # Update input_number to next state
          - service: input_number.set_value
            target:
              entity_id: "{{ scene_tracker_entity }}"
            data:
              value: "{{ next_state }}"

          # Execute action based on new state
          - choose:
              # === STATE 1: ACTIVATE SCENE 1 ===
              - conditions:
                  - condition: template
                    value_template: "{{ next_state | int == 1 }}"
                  - condition: template
                    value_template: "{{ scene_1_enabled and scene_1_entity }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Scene cycling: Activating {{ scene_1_name }}"
                      level: info

                  - service: scene.turn_on
                    target:
                      entity_id: "{{ scene_1_entity }}"
                    data:
                      transition: 2

              # === STATE 2: ACTIVATE SCENE 2 ===
              - conditions:
                  - condition: template
                    value_template: "{{ next_state | int == 2 }}"
                  - condition: template
                    value_template: "{{ scene_2_enabled and scene_2_entity }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Scene cycling: Activating {{ scene_2_name }}"
                      level: info

                  - service: scene.turn_on
                    target:
                      entity_id: "{{ scene_2_entity }}"
                    data:
                      transition: 2

              # === STATE 3: ACTIVATE SCENE 3 ===
              - conditions:
                  - condition: template
                    value_template: "{{ next_state | int == 3 }}"
                  - condition: template
                    value_template: "{{ scene_3_enabled and scene_3_entity }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Scene cycling: Activating {{ scene_3_name }}"
                      level: info

                  - service: scene.turn_on
                    target:
                      entity_id: "{{ scene_3_entity }}"
                    data:
                      transition: 2

              # === STATE 0: DEACTIVATE SCENE (RETURN TO NORMAL) ===
              - conditions:
                  - condition: template
                    value_template: "{{ next_state | int == 0 }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Scene cycling: Deactivated, returning to normal automation"
                      level: info

                  # Resume normal automation - restore circadian color and dynamic brightness
                  # Only if presence detected and lux allows
                  - choose:
                      - conditions:
                          - condition: state
                            entity_id: !input presence_sensor
                            state: "on"
                          - condition: template
                            value_template: "{{ override_active or (current_lux < lux_on_threshold) }}"
                        sequence:
                          - service: light.turn_on
                            target: !input target_lights
                            data:
                              brightness_pct: "{{ calculated_brightness }}"
                              color_temp: "{{ color_temp_mireds }}"
                              transition: 3
                    default:
                      # No presence or lux too high - turn lights off
                      - service: light.turn_off
                        target: !input target_lights
                        data:
                          transition: 3

      # ======================================================================
      # BRANCH 2: APPROACH DETECTION (IMMEDIATE ACTIVATION)
      # ======================================================================
      - conditions:
          - condition: trigger
            id: approach_detected
          - condition: template
            value_template: "{{ approach_sensor_entity != none and approach_sensor_entity != '' }}"
        sequence:
          # Approach detected - turn on lights immediately regardless of lux
          # Check if scene is active first, otherwise use circadian color and dynamic brightness
          - choose:
              # If scene active, don't override it with approach detection
              - conditions:
                  - condition: template
                    value_template: "{{ scene_is_active }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Approach detected but scene {{ current_scene_state }} is active - preserving scene"
                      level: info
            default:
              # No scene active - normal approach behavior
              - service: light.turn_on
                target: !input target_lights
                data:
                  brightness_pct: "{{ calculated_brightness }}"
                  color_temp: "{{ color_temp_mireds }}"
                  transition: 1  # Quick 1-second fade for approach response

          # Wait for presence to clear before starting turn-off sequence
          - wait_for_trigger:
              - platform: state
                entity_id: !input presence_sensor
                to: "off"
            timeout:
              hours: 12
            continue_on_timeout: false

          # Presence cleared - check if scene bypass is active
          # If scene active AND bypass enabled, don't turn off
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ scene_is_active and scene_bypass_timeout }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Presence cleared but scene {{ current_scene_state }} has bypass enabled - keeping lights on"
                      level: info
                  # Exit - don't proceed to turn-off
                  - stop: "Scene bypass timeout enabled - lights stay on"
            default: []

          # Presence cleared - proceed to staged turn-off (if enabled)
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ staged_turnoff }}"
                sequence:
                  # === STAGED TURN-OFF SEQUENCE ===
                  # Stage 1: Wait, then dim to 40% + warm to 1800K
                  - delay:
                      seconds: "{{ effective_stage_1_delay }}"

                  - service: light.turn_on
                    target: !input target_lights
                    data:
                      brightness_pct: "{{ stage_1_brightness_pct }}"
                      color_temp: "{{ warning_color_temp_mireds }}"
                      transition: 3

                  # Stage 2: Wait, then dim to 20% (keep 1800K)
                  - delay:
                      seconds: "{{ effective_stage_2_delay - effective_stage_1_delay }}"

                  - service: light.turn_on
                    target: !input target_lights
                    data:
                      brightness_pct: "{{ stage_2_brightness_pct }}"
                      color_temp: "{{ warning_color_temp_mireds }}"
                      transition: 3

                  # Stage 3: Wait, then turn off completely
                  - delay:
                      seconds: "{{ effective_stage_3_delay - effective_stage_2_delay }}"

                  - service: light.turn_off
                    target: !input target_lights
                    data:
                      transition: 3

            default:
              # Staged turn-off disabled - simple turn-off after stage 3 delay
              - delay:
                  seconds: "{{ effective_stage_3_delay }}"

              - service: light.turn_off
                target: !input target_lights
                data:
                  transition: 3

      # ======================================================================
      # BRANCH 2B: LUX EXCEEDED THRESHOLD (TURN OFF IF BRIGHT)
      # ======================================================================
      - conditions:
          - condition: trigger
            id: lux_exceeded
        sequence:
          # Lux exceeded OFF threshold (room became bright)
          # Turn off lights UNLESS override or scene is active
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ override_active or scene_is_active }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Lux exceeded {{ lux_off_threshold }} but override/scene is active - keeping lights on"
                      level: info
            default:
              # No override/scene - turn off lights due to high ambient light
              - service: light.turn_off
                target: !input target_lights
                data:
                  transition: 5

              - service: system_log.write
                data:
                  message: "Lights turned off - lux exceeded {{ lux_off_threshold }} (current: {{ current_lux }})"
                  level: info

      # ======================================================================
      # BRANCH 3: PRESENCE DETECTED OR LUX DROPPED (MAIN LOGIC + CONTINUOUS UPDATES)
      # ======================================================================
      # This branch handles BOTH presence detection AND lux_dropped triggers
      # Both cases need the continuous monitoring loop for circadian updates
      - conditions:
          - or:
              - condition: trigger
                id: presence_detected
              - condition: trigger
                id: lux_dropped
        sequence:
          # === LUX HYSTERESIS CHECK (ANTI-FLICKER LOGIC) ===
          # Only turn on if:
          # 1. Override is active (ignore lux), OR
          # 2. Lux is below ON threshold

          - choose:
              # Scene active - preserve scene, don't override with circadian
              - conditions:
                  - condition: template
                    value_template: "{{ scene_is_active }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Presence detected but scene {{ current_scene_state }} is active - preserving scene"
                      level: info
                  # Scene is already active, no need to turn on lights

              # Override active - turn on immediately regardless of lux
              - conditions:
                  - condition: template
                    value_template: "{{ override_active }}"
                sequence:
                  - service: light.turn_on
                    target: !input target_lights
                    data:
                      brightness_pct: "{{ calculated_brightness }}"
                      color_temp: "{{ color_temp_mireds }}"
                      transition: 2

              # Override not active and no scene - check lux hysteresis
              - conditions:
                  - condition: template
                    value_template: "{{ current_lux < lux_on_threshold }}"
                sequence:
                  # Lux is below ON threshold - turn on lights immediately
                  - service: light.turn_on
                    target: !input target_lights
                    data:
                      brightness_pct: "{{ calculated_brightness }}"
                      color_temp: "{{ color_temp_mireds }}"
                      transition: 2

            # If neither condition met (lux too high, no override) - do nothing

          # === CONTINUOUS PRESENCE MONITORING ===
          # While presence is active, continuously update brightness and color
          - repeat:
              sequence:
                # Wait for circadian update interval
                - delay:
                    seconds: "{{ circadian_update_sec }}"

                # Check if lights are still on and presence still detected
                - condition: state
                  entity_id: !input presence_sensor
                  state: "on"

                # === RECALCULATE DYNAMIC VALUES FOR THIS ITERATION ===
                # CRITICAL: Variables from top-level are stale - must recalculate here!
                - variables:
                    # Get fresh lux reading
                    loop_current_lux: "{{ states(lux_sensor_entity) | float(0) }}"

                    # Get fresh sun elevation
                    loop_sun_elevation: "{{ state_attr('sun.sun', 'elevation') | float(0) }}"

                    # Recalculate circadian color temperature
                    loop_color_temp_kelvin: >
                      {% if circadian_rhythm %}
                        {% set elevation = state_attr('sun.sun', 'elevation') | float(0) %}
                        {% if elevation < -6 %}
                          1800
                        {% elif elevation >= -6 and elevation < 0 %}
                          {{ (1800 + (elevation + 6) * 200) | int }}
                        {% elif elevation >= 0 and elevation < 10 %}
                          {{ (3000 + (elevation * 50)) | int }}
                        {% elif elevation >= 10 and elevation < 30 %}
                          {{ (3500 + (elevation - 10) * 75) | int }}
                        {% elif elevation >= 30 and elevation < 50 %}
                          {{ (5000 + (elevation - 30) * 25) | int }}
                        {% else %}
                          5500
                        {% endif %}
                      {% else %}
                        3000
                      {% endif %}

                    # Convert to mireds
                    loop_color_temp_mireds: "{{ (1000000 / (loop_color_temp_kelvin | int)) | int }}"

                    # Recalculate dynamic brightness based on current lux
                    loop_calculated_brightness: >
                      {% if dynamic_brightness %}
                        {% set lux = states(lux_sensor_entity) | float(0) %}
                        {% if lux <= 50 %}
                          {{ brightness_at_50_lux }}
                        {% elif lux <= 75 %}
                          {% set range_pct = (lux - 50) / 25 %}
                          {{ (brightness_at_50_lux - (brightness_at_50_lux - brightness_at_75_lux) * range_pct) | int }}
                        {% elif lux <= 100 %}
                          {% set range_pct = (lux - 75) / 25 %}
                          {{ (brightness_at_75_lux - (brightness_at_75_lux - brightness_at_100_lux) * range_pct) | int }}
                        {% elif lux <= 125 %}
                          {% set range_pct = (lux - 100) / 25 %}
                          {{ (brightness_at_100_lux - (brightness_at_100_lux - brightness_at_125_lux) * range_pct) | int }}
                        {% elif lux <= 150 %}
                          {% set range_pct = (lux - 125) / 25 %}
                          {{ (brightness_at_125_lux - (brightness_at_125_lux - brightness_at_150_lux) * range_pct) | int }}
                        {% else %}
                          {{ brightness_at_150_lux }}
                        {% endif %}
                      {% else %}
                        100
                      {% endif %}

                    # Recalculate override state
                    loop_override_active: >
                      {{ override_system_enabled and override_trigger_entity and is_state(override_trigger_entity, 'on') }}

                    # Recalculate scene state
                    loop_scene_is_active: >
                      {{ scene_cycling_system_enabled and scene_tracker_entity and (states(scene_tracker_entity) | int(0)) > 0 }}

                # Update lights with current circadian color and dynamic brightness
                # But SKIP if scene is active (scene overrides circadian)
                # Otherwise only update if lux is still low enough OR override is active
                - choose:
                    # Scene active - skip circadian updates to preserve scene
                    - conditions:
                        - condition: template
                          value_template: "{{ loop_scene_is_active }}"
                      sequence:
                        - service: system_log.write
                          data:
                            message: "Skipping circadian update - scene is active"
                            level: debug

                    # No scene active - normal circadian update
                    - conditions:
                        - condition: template
                          value_template: "{{ loop_override_active or (loop_current_lux < lux_off_threshold) }}"
                      sequence:
                        - service: light.turn_on
                          target: !input target_lights
                          data:
                            brightness_pct: "{{ loop_calculated_brightness }}"
                            color_temp: "{{ loop_color_temp_mireds }}"
                            transition: "{{ circadian_transition_sec }}"

                    # Lux exceeded OFF threshold - turn off immediately
                    # But SKIP if scene is active (scene ignores lux)
                    - conditions:
                        - condition: template
                          value_template: "{{ not loop_override_active and not loop_scene_is_active and (loop_current_lux >= lux_off_threshold) }}"
                      sequence:
                        # Lux is above OFF threshold - turn off lights immediately
                        # Hysteresis (80/150 thresholds) already provides anti-flicker protection
                        - service: light.turn_off
                          target: !input target_lights
                          data:
                            transition: 5

                        # Exit repeat loop
                        - stop: "Lights turned off due to high lux"

              # Continue updating until presence clears or lights turn off
              until:
                - condition: state
                  entity_id: !input presence_sensor
                  state: "off"

          # === PRESENCE CLEARED - START STAGED TURN-OFF ===
          # Check if scene bypass is active first
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ scene_is_active and scene_bypass_timeout }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Presence cleared but scene {{ current_scene_state }} has bypass enabled - keeping lights on"
                      level: info
                  # Exit - don't proceed to turn-off
                  - stop: "Scene bypass timeout enabled - lights stay on"
            default: []

          # No scene bypass - proceed to staged turn-off
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ staged_turnoff }}"
                sequence:
                  # Stage 1: Wait, then dim to 40% + warm to 1800K
                  - delay:
                      seconds: "{{ effective_stage_1_delay }}"

                  - service: light.turn_on
                    target: !input target_lights
                    data:
                      brightness_pct: "{{ stage_1_brightness_pct }}"
                      color_temp: "{{ warning_color_temp_mireds }}"
                      transition: 3

                  # Stage 2: Wait, then dim to 20% (keep 1800K)
                  - delay:
                      seconds: "{{ effective_stage_2_delay - effective_stage_1_delay }}"

                  - service: light.turn_on
                    target: !input target_lights
                    data:
                      brightness_pct: "{{ stage_2_brightness_pct }}"
                      color_temp: "{{ warning_color_temp_mireds }}"
                      transition: 3

                  # Stage 3: Wait, then turn off completely
                  - delay:
                      seconds: "{{ effective_stage_3_delay - effective_stage_2_delay }}"

                  - service: light.turn_off
                    target: !input target_lights
                    data:
                      transition: 3

            default:
              # Staged turn-off disabled - simple turn-off after stage 3 delay
              - delay:
                  seconds: "{{ effective_stage_3_delay }}"

              - service: light.turn_off
                target: !input target_lights
                data:
                  transition: 3

      # ======================================================================
      # BRANCH 4: CIRCADIAN UPDATE CYCLE (BACKGROUND UPDATES)
      # ======================================================================
      # NOTE: This branch handles time_pattern updates when lights are manually on
      # without presence detection. The continuous presence loop in Branch 3 is the
      # primary circadian update mechanism during normal occupancy.
      - conditions:
          - condition: trigger
            id: circadian_update
          - condition: template
            value_template: "{{ circadian_rhythm }}"
          # Skip if scene is active (scene overrides circadian)
          - condition: template
            value_template: "{{ not scene_is_active }}"
          # Only proceed if presence is detected (this branch complements the loop)
          - condition: state
            entity_id: !input presence_sensor
            state: "on"
        sequence:
          # Recalculate current values (variables from top are stale)
          - variables:
              time_lux: "{{ states(lux_sensor_entity) | float(0) }}"
              time_sun_elevation: "{{ state_attr('sun.sun', 'elevation') | float(0) }}"

              time_color_kelvin: >
                {% if circadian_rhythm %}
                  {% set elevation = state_attr('sun.sun', 'elevation') | float(0) %}
                  {% if elevation < -6 %}
                    1800
                  {% elif elevation >= -6 and elevation < 0 %}
                    {{ (1800 + (elevation + 6) * 200) | int }}
                  {% elif elevation >= 0 and elevation < 10 %}
                    {{ (3000 + (elevation * 50)) | int }}
                  {% elif elevation >= 10 and elevation < 30 %}
                    {{ (3500 + (elevation - 10) * 75) | int }}
                  {% elif elevation >= 30 and elevation < 50 %}
                    {{ (5000 + (elevation - 30) * 25) | int }}
                  {% else %}
                    5500
                  {% endif %}
                {% else %}
                  3000
                {% endif %}

              time_color_mireds: "{{ (1000000 / (time_color_kelvin | int)) | int }}"

              time_brightness: >
                {% if dynamic_brightness %}
                  {% set lux = states(lux_sensor_entity) | float(0) %}
                  {% if lux <= 50 %}
                    {{ brightness_at_50_lux }}
                  {% elif lux <= 75 %}
                    {% set range_pct = (lux - 50) / 25 %}
                    {{ (brightness_at_50_lux - (brightness_at_50_lux - brightness_at_75_lux) * range_pct) | int }}
                  {% elif lux <= 100 %}
                    {% set range_pct = (lux - 75) / 25 %}
                    {{ (brightness_at_75_lux - (brightness_at_75_lux - brightness_at_100_lux) * range_pct) | int }}
                  {% elif lux <= 125 %}
                    {% set range_pct = (lux - 100) / 25 %}
                    {{ (brightness_at_100_lux - (brightness_at_100_lux - brightness_at_125_lux) * range_pct) | int }}
                  {% elif lux <= 150 %}
                    {% set range_pct = (lux - 125) / 25 %}
                    {{ (brightness_at_125_lux - (brightness_at_125_lux - brightness_at_150_lux) * range_pct) | int }}
                  {% else %}
                    {{ brightness_at_150_lux }}
                  {% endif %}
                {% else %}
                  100
                {% endif %}

              time_override: >
                {{ override_system_enabled and override_trigger_entity and is_state(override_trigger_entity, 'on') }}

          # Update color temperature based on current sun position
          # Only if lux allows OR override is active
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ time_override or (time_lux < lux_off_threshold) }}"
                sequence:
                  - service: light.turn_on
                    target: !input target_lights
                    data:
                      brightness_pct: "{{ time_brightness }}"
                      color_temp: "{{ time_color_mireds }}"
                      transition: "{{ circadian_transition_sec }}"

    # === DEFAULT BRANCH (FALLBACK) ===
    default: []
